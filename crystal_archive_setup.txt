# .github/workflows/ci.yml
name: Crystal Archive CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.10', '3.11', '3.12']
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e .[dev]
    
    - name: Lint with ruff
      run: |
        ruff check src/
    
    - name: Type check with mypy
      run: |
        mypy src/crystal_archive --ignore-missing-imports
    
    - name: Test with pytest
      run: |
        pytest tests/ -v --cov=crystal_archive --cov-report=xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        fail_ci_if_error: false

  integration:
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install package
      run: |
        pip install -e .
    
    - name: Run end-to-end test
      run: |
        # Create test data
        mkdir -p test_data
        echo "Test content" > test_data/test.txt
        
        # Encode
        crystal-archive encode test_data --out encoded --profile A
        
        # Simulate damage
        crystal-archive simulate --tile-loss 0.1 --bitflip 0.01 --runs 3 --out reports
        
        # Decode
        crystal-archive decode encoded --out recovered
        
        # Verify
        crystal-archive verify encoded
        
        # Check recovery
        diff test_data/test.txt recovered/test.txt

---

# setup.py (alternative to pyproject.toml for editable installs)
#!/usr/bin/env python
"""Setup script for Crystal Archive."""

from setuptools import setup, find_packages

setup(
    name="crystal-archive",
    version="1.0.0",
    packages=find_packages(where="src"),
    package_dir={"": "src"},
    python_requires=">=3.10",
)

---

# Makefile
.PHONY: install test clean build docs

install:
	pip install -e .[dev]

test:
	pytest tests/ -v --cov=crystal_archive

lint:
	ruff check src/
	mypy src/crystal_archive --ignore-missing-imports

format:
	black src/ tests/
	isort src/ tests/

clean:
	rm -rf build/ dist/ *.egg-info
	rm -rf voxels/ reports/ recovered/
	find . -type d -name __pycache__ -exec rm -rf {} +
	find . -type f -name "*.pyc" -delete

build:
	python -m build

docs:
	# Generate documentation if using sphinx
	cd docs && make html

demo:
	@echo "Running Crystal Archive demo..."
	@echo "1. Encoding sample data..."
	crystal-archive encode examples/sample_data --out build/demo --profile A
	@echo "2. Running simulations..."
	crystal-archive simulate --tile-loss 0.15 --runs 5 --out build/reports
	@echo "3. Decoding archive..."
	crystal-archive decode build/demo --out build/recovered
	@echo "4. Verifying integrity..."
	crystal-archive verify build/demo
	@echo "Demo complete! Check build/ directory for outputs."

---

# docs/DESIGN.md
# Crystal Archive Design Document

## Architecture Overview

Crystal Archive implements a multi-layered approach to data preservation, inspired by
information theory principles and real-world archival standards.

## Design Decisions

### 1. Error Correction Strategy

We use a concatenated code design with two layers:

- **Inner Code (LDPC)**: Handles random bit errors from optical readout noise
- **Outer Code (Reed-Solomon)**: Recovers from erasures (complete tile/plane losses)

This separation allows optimal handling of different error types while maintaining
reasonable computational complexity.

### 2. Interleaving

Deep interleaving spreads codeword symbols across physical regions, converting
burst errors (scratches, cracks) into sparse random errors that LDPC handles well.

The pseudo-random permutation uses a seeded PRNG for deterministic deinterleaving
without storing the full permutation table.

### 3. Voxel Mapping

Gray coding ensures adjacent symbols differ by only one bit, minimizing errors
from measurement uncertainty near decision boundaries.

Two modes balance density vs. robustness:
- **3-bit**: Conservative, wide decision margins
- **5-bit**: Aggressive, 67% higher density

### 4. Self-Description

Following OAIS principles, the archive contains complete decoding instructions
in both human-readable (etched primer) and machine-readable (manifest) forms.

### 5. Integrity Verification

Multiple layers ensure data authenticity:
- File-level SHA-256 hashes
- Merkle tree for efficient partial verification
- Optional Ed25519 signatures for tamper detection

## Trade-offs

### Density vs. Reliability

Profile A prioritizes reliability with lower code rates and coarser quantization.
Profile B pushes density limits but requires better optical systems and calibration.

### Complexity vs. Performance

We use simplified LDPC (demonstration) rather than optimized codes like those in
DVB-S2. Production systems should use proven implementations from standards.

### Compression

Zstandard offers excellent speed/ratio balance. XZ provides maximum compression
for archival masters where encoding time is not critical.

## Future Enhancements

1. **Adaptive Decoding**: Adjust parameters based on measured channel quality
2. **Fountain Codes**: Replace RS with RaptorQ for better erasure handling
3. **DNA Integration**: Hybrid optical+DNA for extreme density/longevity
4. **Quantum Error Correction**: Prepare for quantum storage media

## Standards Compliance

- **OAIS Reference Model** (ISO 14721): Information packages and metadata
- **PREMIS**: Preservation metadata standards
- **BagIt**: File packaging conventions
- **Dublin Core**: Metadata elements

## References

- Shannon, C.E. (1948). "A Mathematical Theory of Communication"
- MacKay, D.J.C. (2003). "Information Theory, Inference, and Learning Algorithms"
- Long Now Foundation. "The Rosetta Project"
- Microsoft Research. "Project Silica"

---

# docs/primer/instructions.md
# Crystal Archive Reader Instructions

## For Future Civilizations

This is a data archive stored in optical crystal using five dimensions:
- X, Y, Z position
- Light orientation angle
- Light retardance level

## Basic Concepts

### Binary Numbers
```
0 = ○
1 = ●

Examples:
3 = ○●● 
5 = ●○●
8 = ●○○○
```

### Measurement Units
- Angle: 0° to 180° (half circle)
- Retardance: 0 to 1 wavelength
- Position: micrometers (10^-6 meter)

## Reading Voxels

Each voxel stores information as:
1. Measure polarization angle
2. Measure birefringence strength
3. Convert to symbol using tables below

### 3-Bit Encoding (Simple)
```
Symbol | Angle | Retardance | Binary
-------|-------|------------|--------
   0   |   0°  |    0.25λ   |  000
   1   |  45°  |    0.25λ   |  001
   2   |  90°  |    0.25λ   |  010
   3   | 135°  |    0.25λ   |  011
   4   |   0°  |    0.75λ   |  100
   5   |  45°  |    0.75λ   |  101
   6   |  90°  |    0.75λ   |  110
   7   | 135°  |    0.75λ   |  111
```

## Error Correction

Data includes redundancy for recovery:
1. Group symbols into blocks
2. Check parity equations
3. Correct errors using algebra
4. Verify with hash functions

## File Structure

```
[HEADER] → [COMPRESSED DATA] → [PARITY] → [MANIFEST]
```

Manifest contains:
- List of files
- Compression method
- Error correction parameters
- Integrity checksums

## Calibration

Use these patterns to calibrate reader:

### Focus Target
```
╋ ╋ ╋
╋ ╋ ╋
╋ ╋ ╋
```

### Angle Reference
```
│ ╱ ─ ╲
│ ╱ ─ ╲
│ ╱ ─ ╲
```

## Mathematical Foundation

Shannon Information: H = -Σ p(x) log₂ p(x)
Hamming Distance: d(x,y) = Σ(xᵢ ≠ yᵢ)
Reed-Solomon: GF(2⁸) polynomial codes

---

# example_usage.py
#!/usr/bin/env python
"""Example usage of Crystal Archive."""

from pathlib import Path
from crystal_archive import encode_folder, decode_archive, ChannelSimulator

def main():
    # Example 1: Basic encoding
    print("Example 1: Basic Encoding")
    print("-" * 40)
    
    # Create some test data
    test_dir = Path("test_data")
    test_dir.mkdir(exist_ok=True)
    (test_dir / "message.txt").write_text(
        "This message is preserved for future generations.\n"
        "Encoded in crystal, it may outlast civilizations."
    )
    
    # Encode with conservative profile
    encoded_dir = Path("encoded")
    output, manifest = encode_folder(test_dir, encoded_dir, profile="A")
    
    print(f"Files encoded: {len(manifest.data['files'])}")
    print(f"Merkle root: {manifest.data['integrity']['merkle_root'][:32]}...")
    
    # Example 2: Simulate damage and recovery
    print("\nExample 2: Damage Simulation")
    print("-" * 40)
    
    import numpy as np
    
    # Create simulated voxel data
    n_voxels = 10000
    original = np.random.randint(0, 8, n_voxels, dtype=np.uint8)
    
    # Apply damage
    simulator = ChannelSimulator(seed=42)
    damaged, stats = simulator.simulate(
        original,
        tile_loss=0.10,  # 10% tile loss
        bitflip_p=0.01   # 1% bit flips
    )
    
    errors = np.sum(original != damaged)
    print(f"Voxels damaged: {errors}/{n_voxels} ({100*errors/n_voxels:.1f}%)")
    print(f"Expected recovery: {'Yes' if errors/n_voxels < 0.15 else 'No'}")
    
    # Example 3: Decode archive
    print("\nExample 3: Decoding")
    print("-" * 40)
    
    decoded_dir = Path("decoded")
    try:
        decode_archive(encoded_dir, decoded_dir)
        
        # Verify content
        recovered_text = (decoded_dir / "message.txt").read_text()
        print("Recovery successful!")
        print(f"Message: {recovered_text[:50]}...")
    except Exception as e:
        print(f"Decoding failed: {e}")
    
    # Example 4: Advanced configuration
    print("\nExample 4: Custom Configuration")
    print("-" * 40)
    
    # Use aggressive profile for higher density
    output_b, manifest_b = encode_folder(
        test_dir, 
        Path("encoded_aggressive"),
        profile="B",  # 5-bit voxels, higher density
        seed=12345,   # Custom seed
        sign=True     # Enable digital signatures
    )
    
    profile_b = manifest_b.data["encoding"]["profile_params"]
    print(f"Profile B density: {profile_b['voxel_mode']} ({5} bits/voxel)")
    print(f"LDPC rate: {profile_b['ldpc_rate']}")
    print(f"RS overhead: {profile_b['rs_overhead']*100:.0f}%")

if __name__ == "__main__":
    main()

---

# tests/test_voxel_mapping.py
"""Test voxel mapping and Gray coding."""

import pytest
import numpy as np
from crystal_archive.mapping.voxel_map import VoxelMapper


def test_gray_code_properties():
    """Test Gray code has single-bit changes."""
    mapper = VoxelMapper(mode="3bit")
    
    # Check 2-bit Gray code
    gray_2bit = [0b00, 0b01, 0b11, 0b10]
    for i in range(len(gray_2bit) - 1):
        diff = gray_2bit[i] ^ gray_2bit[i+1]
        # Should differ by exactly one bit
        assert bin(diff).count('1') == 1


def test_symbol_round_trip():
    """Test symbol to voxel to symbol conversion."""
    for mode in ["3bit", "5bit"]:
        mapper = VoxelMapper(mode=mode)
        
        # Test all possible symbols
        max_symbol = 8 if mode == "3bit" else 32
        for symbol in range(max_symbol):
            # Convert to voxel
            angles, retardances = mapper.symbols_to_voxels(np.array([symbol]))
            
            # Add small noise
            angles += np.random.normal(0, 0.5, 1)
            retardances += np.random.normal(0, 0.01, 1)
            
            # Convert back
            recovered, reliability = mapper.voxels_to_symbols(angles, retardances)
            
            # Should recover original
            assert recovered[0] == symbol


def test_bits_to_symbols():
    """Test bit packing into symbols."""
    mapper = VoxelMapper(mode="3bit")
    
    # Test data
    bits = np.array([1, 0, 1, 0, 1, 1], dtype=np.uint8)  # 101 011 = 5, 3
    symbols = mapper.bits_to_symbols(bits)
    
    assert len(symbols) == 2
    assert symbols[0] == 5  # 101 binary
    assert symbols[1] == 3  # 011 binary
    
    # Round trip
    recovered_bits = mapper.symbols_to_bits(symbols)
    assert np.array_equal(recovered_bits[:6], bits)


def test_soft_decision_output():
    """Test reliability values for soft-decision decoding."""
    mapper = VoxelMapper(mode="5bit")
    
    # Perfect measurement
    perfect_angle = 45.0
    perfect_retard = 0.5
    symbols, reliabilities = mapper.voxels_to_symbols(
        np.array([perfect_angle]),
        np.array([perfect_retard]),
        soft_output=True
    )
    
    # Should have high reliability
    assert reliabilities[0] > 0.9
    
    # Noisy measurement
    noisy_angle = 33.75  # Between 22.5° and 45°
    symbols_noisy, reliabilities_noisy = mapper.voxels_to_symbols(
        np.array([noisy_angle]),
        np.array([perfect_retard]),
        soft_output=True
    )
    
    # Should have lower reliability
    assert reliabilities_noisy[0] < reliabilities[0]